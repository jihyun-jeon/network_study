# 7장 캐시

<br /><br />

## 캐시의 장점

1. 네트워크 비용 절감
2. 네트워크 병목 감소
3. 갑작스런 트래픽 급증 시 발생되는 서버 부하 감소
4. 거리로 인한 지연 현상 감소

<br /><br />

## 재검사 Revalidation

: 캐시된 정보가 가장 최신인지 신선도 검사하는 것

### 재검사 과정

- 1 . 재검사 요청 : If-Modified-Since 헤더 사용

- 2-1. 재검사 적중 : 서버는 콘텐츠가 동일하면 304 Not Modified 응답 전송

- 2-2. 재검사 부적중 : 캐시된 사본의 유효기간 지났다면 콘텐츠 + 200 응답 전송

- 2-3. 객체 삭제됨 : 서버의 객체 삭제됐다면 404 Not Found 응답 전송

## 적중률

: 캐시가 요청을 처리하는 비율 (=문서 적중률, 문서 적중비)

- 0에서 1까지 값으로 표현하거나, 0% ~ 100%로 표현하기도 함
- 0%면, 요청 내용이 캐시된 데이터에 부적중해서 네트워크 통신했다는 의미
- ⇒ 총 대기시간/지연을 줄여준다

## 바이트 적중률

: 캐시를 통해 제공된 모든 문서의 바이트 비율

- 트래픽이 절감된 정도
- 100%면 ,모든 바이트가 캐시로부터 가져왔음을 의미
- ⇒ 대역폭 절약을 최적화해준다

## 적중과 부적중 구별법

1. 응답의 Date 헤더 값이 현재시간보다 이전이라면 캐시된 값임을 알 수 있다.
2. 응답의 Age 헤더를 확인

<br /><br />

## 캐시 토폴로지 Topology

- Topology: 네트워크 요소(링크, 노드 등)들을 물리적으로 연결해 놓은 방식

<br />

## Private Cache : 개인 전용 캐시

: 웹 브라우저에 저장되는 캐시로 다른 컴퓨터에서 접근 못하는 개인 전용 캐시

## Public(Shared) Cache : 공용 캐시

: 웹 브라우저 ← (프록시) → 서버 사이에서 동작하는 캐시

1. Proxy Cache

   : **포워드 프록시**에서 동작하는 캐시

   - 많은 중복된 요청에 공유된 캐시를 제공하여 네트워크 통신 절약 가능

2. Managed Cache

   : AWS, CloudFlare 같은 **CDN이나, 리버스 프록시**에서 동작하는 캐시

   - 관리자 패널에서 캐시 설정하거나, 리버스 프록시 설정으로 관리 가능

### 1. 포워드 프록시

: 브라우저 - 인터넷 사이에 위치한 것

- 브라우저 ↔ `프록시` ↔ 인터넷 ↔ 서버
- 캐싱, 특정 리소스 접근 제한, 클라이언트 익명성(IP노출 방지) 시 사용

### 2. 리버스 프록시

: 인터넷 - 서버 사이에 위치한 것

- 브라우저 ↔ 인터넷 ↔ `프록시` ↔ 서버
- 캐싱 로드밸런싱, 무중단 배포, 디도스 공격 보호 시, SSL 암호화(서버는  
  SSL 통신으로 인한 추가 비용 제거) 사용

참고 - [Cloudflare- 역방향 프록시란? | 프록시 서버 설명](https://www.cloudflare.com/ko-kr/learning/cdn/glossary/reverse-proxy/)

<br />

## 캐시 처리 과정

1. HTTP 요청 받고
2. 요청 메시지 파싱 후 URL, 헤더 추출
3. 신선도 검사
4. 응답 생성
5. 클라이언트로 전달
6. 로그파일에 트랜잭션 로깅

<br /><br />

# 캐시 관련 HTTP 헤더

## Cache-Control

: 캐시 지시어

`Cache-Control: max-age=2000`

- 캐시 유효 시간. 서버로부터 온 이후 흐른 초 단위

`Cache-Control: no-cache`

- 매번 원 서버에 캐시 유효성 검증
  모든 캐시 가능하지만 쓰기 전에 항상 원 origin 서버에 재검사/검증하고 사용 - 캐시 하지말라는 뜻 아님!

`Cache-Control: no-store`

- 캐시 저장 안함
  데이터에 민감한 정보 있으므로 저장하면 안됨. 메모리에서 사용하고 최대한 빨리 삭제

`Cache-Control: must-revalidate`

- 만료된 캐시만 서버에 유효성 검증

## Expires (deprecated)

: 캐시 만료일 지정

- `Expires: Mon, 01 Jan 1990 00:00:00 GMT`
- 캐시 만료일을 정확한 날짜로 지정
- HTTP 1.0 부터 사용
- 지금은 Cache-Contol:max-age 권장
- Cache-Control: max-age 같이 사용 시 Expires는 무시됨

<br /><br />

### 검증헤더

1. ETag: "v1.0", ETag:" 83832cdv98v9f8vf9fd"
2. Last-Modified: Wen, 26 Dec 2022 02:52:11 GMT

### 조건부 요청 헤더

1. If-Match, If-None-Match : ETag 값 사용
2. If-Modified-Since, If-UnModified-Since: Last-Modified 값 사용

<br /><br />

1. **Last-Modified 와 If-Modified-Since**

   `Last-Modified`

   : 캐시 제어할 수 있는 검증 헤더

   - 마지막 수정시간을 서버 응답 헤더에 포함

   **`If-Modified-Since: <캐시된 마지막 수정일date>` (IMS)**

   : 캐시의 유효시간이 초과돼도 조건부 헤더를 이용해 조건부 요청 가능

2. 단점

   - 1초 미만 단위의 캐시 조정 불가
   - 데이터가 수정되어 날짜가 변경됐지만 사실 변화가 없는 경우
   - 공백, 주석같이 중요치 않은 변경발생 시 캐시 유지하고 싶은 경우

<br />

---

<br />

1. **ETag (Entity Tag) 와 If-None-Match**

: Last-Modified와 If-Modified-Since보다 좀 더 간단한 방식

`ETag`
: 서버에서 캐시를 완전히 제어하여 관리하는 검증헤더

`If-None-Match`
: ETag값으로 조건부 요청

- 캐시용 데이터에 임의의 고유한 버전 이름 달아둠 `v2.6`
- 데이터 변경 시 이름 바꿔서 변경 (Hash 재생성) `v.3.0`
- 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기

### 작동방식

- 서버에서 헤더에 ETag 작성하여 응답
- 클라이언트의 캐시에서 해당 ETag 값 저장
- 캐시 유효시간 초과해도 재요청하는 경우 ETag값 검증하는 If-None-Match를 요청 헤더에 작성하여 전송

<br />

- 약한 검사기
  : 콘텐츠 조금 바뀌면 서버가 같은 콘텐츠라고 응답하여 캐시 무효화 하지 않는 것
  - ETag: W/"v1.0" `W/` 접두사가 값에 들어가면 약한 검사기
- 강한 검사기
  : 콘텐츠 변경될때마다 바뀜

---

<br /><br />

## 알고리즘

캐시의 신선도 여부를 알려면 **캐시 사본 나이, 신선도 수명**을 계산하면 됨

- 캐시 사본 나이 < 신선도 수명 ⇒ 신선한 사본

<aside>
💡 클록 스큐 Clock Shew : 컴퓨터 간 시계 시간 차이로 발생하는 문제
</aside>

<br />

### 응답의 나이

서버에서 생성(재검사 시부터)됐을 때부터 지금까지 총 시간

`= 문서가 캐시에 도착했을 때 나이 + 캐시에 머무른 시간`

1. 문서가 캐시에 도착했을 때 나이

   = 겉보기 나이 = 응답 받은 시각 - Date 헤더값

   = 보정된 겉보기 나이 = max(겉보기 나이, Age 헤더값)

   ⇒ 보정된 겉보기 나이 + 응답 지연 추정값

2. 캐시에 체류한 시간

   = 현재 시각 - 응답 받은 시각

<br />

### 신선도 수명

서버와 클라이언트의 제약조건에 의존함

- 서버 신선도의 나이 제약에서 이후 클라이언트 제약에 맞게 수정한다.
- 책 참고 p.222 - Max Age, Expires, Last Modified, Max Stale, Min Fresh 헤더 값 사용
