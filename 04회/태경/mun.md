- 일자 : 24/4/5
- 4회차 : 7, 8, 9장

<br/><br/><br/><br/>

# 7장 - 응용계층

## 프로토콜

- HTTP - PORT 80번 : 웹 사이트 접속
- DNS - PORT 53번 : 이름 해석
- FTP - PORT 20(데이터전송), 21(명령/응답 제어) : 파일 전송
- SMTP - 25번 : 이메일 송신
- POP3 - 110 : 이메일 수신

## HTTP 요청 Messages

- 응용계층 - 바이너리 프레임 : 헤더 프레임, 데이터 프레임

1. Start Line : 요청의 상태

- `GET /index.html HTTP/1.1` : Method / Path or Query / HTTP Version

2. Header : 전송에 필요한 부가정보

   - ![](https://velog.velcdn.com/images/xmun74/post/d4daa0a2-7d05-4eb5-bdca-6b28651a178a/image.png)

3. 1줄 공백 : Header와 Body 구분하기 위한 빈줄
4. Body : 전송할 데이터

## HTTP 응답 Messages

1. Status line : 응답의 상태

- `HTTP/1.1 200 OK`: HTTP Version / Status Code Status Text

2. Header
   - ![](https://velog.velcdn.com/images/xmun74/post/d6648ecb-78fb-4245-a3e8-33394a5966fc/image.png)
3. 1줄 공백
4. Body : 응답 데이터

## HTTP Version

- 참고 : https://beomy.github.io/tech/etc/http-version/

### HTTP 1.0 (1996)

- 요청/응답 메시지에 `HTTP Header` 추가
- 요청 메시지에 `Method`, `Version` 추가
- 응답 메시지에 `Status Code` 추가하여 성공/실패 여부 파악
- `Content-Type`으로 HTML 외 문서 전송 가능해짐
- 문제
  - 단기 커넥션 : 연결 당 1개 요청 1개 응답만 처리 => 매요청마다 연결-해제해야해서 오버헤드, 서버부하 문제 => 1.1에서 개선됨

### HTTP 1.1 (1997)

- 현재 가장 많이 사용하는 버전.
- `Keep-alive` : 연결 수립되면 데이터 교환 마칠떄까지 유지하고 교환 종료시 연결 종료하는 구조로 1.1부터 추가된 기능
- `PipeLining` : 앞 요청의 응답을 기다리지 않고, 순서대로 여러 요청 전송 후 순서맞게 응답 받는 방식 (여러 요청을 동시에 처리하는 것은 아님)
- `Cache-Control` 헤더로 캐시 제어 기능 추가
- 문제
  - `HOLB(Head-Of-Line Blocking)` : 앞 요청이 오래걸리면 뒤 작업도 Blocking되어 지연됨
  - 연속 요청으로 Header 중복 발생

### HTTP 2.0 (2015)

- Multiplexed Streams : 동시에 여러 요청 처리 가능해짐

<br/><br/>

# DNS 서버

Domain Name System : IP 주소를 도메인 주소로 변경해주는 서버

### DNS 질의

1. 1단계 질의 : `.(루트)`
2. 2단계 질의 : `.com` `.net` … 인지 확인
3. 3단계 질의 : `www.google.com` 요청하려는 IP 주소 질의

# DHSP 서버

Dynamic Host Configuration Protocol : 사용자들의 IP 주소를 할당, 회수를 자동으로 해주는 서버

1. 사용자 컴퓨터가 DHCP 서버 찾기
2. DHCP 서버가 사용자에게 IP주소 할당여부 제안
3. 사용자가 IP 주소 요청
4. DHCP서버가 IP 할당

# SMTP

: 이메일 송신자가 사용하는 프로토콜

- PORT 번호 : 25

1. A 컴퓨터 → 25번 PORT SMTP → 메일서버

# POP3/IMAP

: 이메일 수신자가 사용하는 프로토콜

- PORT 번호 : 110
- 편지함에서 이메일 가져오면 서버에서 삭제됨
  - IMAP : 삭제 안할 떄 사용하는 프로토콜

## 응용계층의 로드밸런서

: 서비스별로 부하를 분산

- 전송계층의 로드밸런서 기능까지 포함하고 있음
- URI, HTTP 헤더, 쿠키 등 내용으로 부하 분산
- 로그인인증/검색/결제 등 서버 분리해서 사용자 접속을 분산 처리 가능

<br/><br/><br/><br/>

---

# 8장 - 유선 통신

![](https://velog.velcdn.com/images/xmun74/post/2a1f9596-d45f-46fc-bdfe-6ab1005b8667/image.png)

1. 응용계층 : GET /index.html HTTP/1.1
2. 전송계층 : 헤더 - 송신자 PORT 1025번, 수신자 PORT 80번 / 세그먼트 Segment
3. 네트워크 계층 : 헤더 - 송,수신자 IP 주소 / 패킷 Packet
4. 데이터링크 계층 : 헤더 - 송,수신자 MAC 주소 / 프레임 Frame
5. 물리 계층 : 프레임을 랜카드를 통해서 전기신호로 변환

## http://www.google.com 입력하면 일어나는 일은?

1. 웹 사이트에 url을 입력하여 요청
2. DNS 서버는 도메인명 www.google.com에 해당하는 IP주소를 찾아서 응답
   - DNS서버가 모르면 다른 DNS서버에 질의해서 전달받음
3. 웹 브라우저가 받은 IP주소로 웹서버에게 html 문서 요청
4. 웹 서버는 사용자 요청에 응답
5. 웹브라우저는 화면에 데이터 출력

---

## 장비 관점에서 이해하기

: IP 주소를 알아냈지만 `어떻게?` 가야할까.

- 실직적 통신을 위해 논리주소인 IP주소 => 물리주소인 MAC주소로 변환해야함

### 라우터 A의 과정

1. 송신자 컴퓨터 : 응용->물리 7계층 다 거치고
2. 스위치 : 데이터 링크 -> 물리 거치고
3. 라우터 A : 네트워크 -> 데이터링크 -> 물리 거치고

- 스위치가 웹 서버의 MAC주소를 가지기 위해서 수신자의 MAC주소를 라우터의 MAC주소로 변경하고 물리계층에서 전기신호로 변환하여 라우터 A로 전달한다.
- 라우터로 넘어온 데이터에서 헤더에 있는 수신자 IP를 확인
- 라우터A는 데이터링크계층에서 수신자 MAC주소가 자신과 같으면 이더넷 헤더 떼고 네트워크 계층에 전달
- 라우터는 라우팅테이블에서 수신자IP주소가 등록되어있는지 확인
- 송신자의 IP주소를 자신의 IP주소로 교체
- 라우터A,B는 2개의 IP주소 가짐, 내부용(192.168.10.1), 외부용(172.16.0.1/24)

- 라우터 간 통신하기 위해서
  1. 라우터A는 송신자의 MAC주소를 라우터A(자신)의 MAC주소로 변경
  2. 라우터B에 수신자의 MAC주소를 라우터 B의 MAC주소로 변경
  3. 떼어냈던 이더넷 헤더를 다시 합쳐서 데이터 링크 계층으로 전송
  4. 데이터를 전기신호로 변환하여 물리계층인 라우터B로 전송

### 라우터 B의 과정

1. 라우터 B : 네트워크 -> 데이터링크 -> 물리 거치고
2. 스위치 : 데이터 링크 -> 물리 거치고
3. 송신자 컴퓨터 : 물리 -> 응용 7계층 다 거치고

- 데이터링크 계층에서 목적지MAC가 자신과 같으면 이더넷 헤더 분리해서 네트워크 계층 전달
- 네트워크 계층은 수신자IP주소가 자신의 라우팅테이블에 있는지 확인
- 송신자 IP(172.16.0.2)를 라우터 B의 IP주소(192.168.20.1)로 변경
- 변경된 헤더는 데이터 링크 계층으로 전송
- 데이터링크 계층은 이더넷 헤더 결합하여 MAC주소를 변경
- 송신자 MAC주소를 라우터 B의 주소로 변경
- 수신자 MAC주소는 웹 서버 주소로 변경
- 데이터 전기신호 변환 후 물리 계층인 스위치 B로 전달
- 스위치B는 데이터링크에서 이더텟 헤더 결합
- 물리계층에서 데이터 전기신호 변환 후 웹 서버에 전달

---

## 수신자 관점에서 이해하기

- 흐름 : 물리계층 -> 응용계층

1. 물리 : 스위치 B에서 온 전기신호가 데이터 링크에 전달
2. 데이터링크 : 수신자 MAC 주소가 자신과 같으면 이더넷 헤더 분리
3. 네트워크 : 수신자 IP주소 확인 후 자신과 같으면 IP헤더 분리
4. 전송 : TCP PORT번호 확인하고 TCP 헤더 분리
5. 응용 : 헤더가 다 분리되고 남은 데이터인 index.html만 컴퓨터 A에게 보여줌

<br /><br /><br /><br />

# 9장 - 무선 통신

## 무선 랜

: 케이블 선 없이 통신하는 네트워크.

- 무선 공유기(무선 액세스 포인트) : 유선 랜과 무선 랜 연결해주는 장치.
- 클라이언트 : 무선 액세스 포인트에 연결된 노트북, 태블릿, 핸드폰 등
- 무선 랜은 `전자기파`를 사용하여 데이터 전송

#### 전자기파?

: 전기적 변화있을 때 생기는 파동. 전기장과 자기장이 번갈아가며 발생하는데 이를 이용해서 통신 가능함

- 저주파 또는 고주파의 무선 주파수 대역 사용하여 통신

1. 저주파(2.4GHz) - 파장이 길어서 전파가 멀리 전달됨
2. 고주파(5GHz) - 파장이 짧아서 전파가 멀리 전달안됨

### 무선 랜 구성방식

1. `Infrastructure`
   : 무선 랜 네트워크에 연결된 모든 장치가 무선 액세스 포인트에 연결되는 방식

- 주로 집, 사무실에서 안전한 무선 네트워크 환경 제공할 때

2. `Ad-hoc(애드혹)`
   : 무선 액세스 포인트 없이 장치 간 직접 통신

- 주로 작은 범위 내에서 장치간 통신할 때

### 무선 랜 규격

: IEEE(전기전자기술자협회)에서 제정한 규격으로 전송속도, 주파수 대역, 보안, 전송거리 등 정의

- 802.11a
- 802.11b
- 802.11g
- 802.11n
- 802.11ac
- 802.11ax : 대용량 파일 전송, 스트리밍 서비스에서 고품직 서비스 제공하는 규격
- 여려 규격 표시할 땐 802.11.g/n/ac 처럼 표시

### 무선 랜 통신방법

- SSID 이용하여 무선공유기와 클라이언트 통신

  - `SSID(Service Set IDentifier:서비스 세트 식별자)` : 하나의 무선 랜을 다른 무선 랜과 구분하는 식별자

- 특정 무선 랜에 접속하려는 무선공유기나 클라이언트는 반드시 동일 SSID를 사용해야 함
- 무선공유기는 미리 정해진 SSID를 가짐
- 클라이언트는 SSID 검색하여 해당 네트워크에 연결 가능

1. 무선공유기는 주기적으로 클라이언트에게 브로드캐스트로 Beacon 비콘 메시지 전송.

   - `Beacon` : 가까운 범위에 있는 주변 기기에 정보 전달하는 무선 통신

2. 신호받은 클라이언트는 자신의 SSID와 같은지 무선공유기에 문의
3. 같은 SSID의 무선공유기가 응답함
4. 클라이언트가 무선공유기에 설정된 인증방식 확인 후 연결 요청
5. 무선공유기가 연결 승인하면 통신 가능한 상태됨

- 거리가 멀 경우 문제
  : 무선공유기 연결 , 통신 속도 문제
- 무선공유기 여러대 둘 경우 채널 간섭 발생 문제
  : 무선공유기는 동시에 접속가능하도록 주파수 대역을 분리하는데(분리된 주파수 대역=채널) 채널 폭이 좁으면 간섭 발생 가능
  - 다른 규격이면 주파수가 달라서 간섭 발생 안함
  - 다른 채널이어도 같은 규격 사용하면 전파 간섭 발생할 수 있음
